# 二叉堆

## 一、一些在学习此内容所需要的准备

### 1 需要提前了解的知识

​	1、完全二叉树的概念，具体需要参考二叉树和二叉搜索树那一章。

​	2、时间复杂度的计算，以及记号。

​	3、熟悉c或c++的基本语法。

## 二、二叉堆的定义

​		二叉堆是一种基于树的数据结构，它是一棵树，同时它还是一棵==完全二叉树==。普通堆分为两种，==大根堆== 和==小根堆== ，他们之间的定义只有细微的差别。除了二叉堆之外，堆这个大家族还斐波那契堆，B-heap等。

### 1 二叉堆的性质

​		我们先以大根堆的性质为例，小根堆与其类似。

​		1、是一棵==完全二叉树==。

​		2、树中的一个结点假设为$c$，如果其含有父结点，那么父结点中存储的关键字大小大于等于$c$ 中关键字大小。

​		于是我们就可以推出对于小根堆，父结点中存储的关键字大小小于等于$c$ 中关键字大小。

​		根据性质2，我们可以得出一个重要的推论。

==推论:==对于大根堆，其树的根结点含有树中最大的关键字。而对于小根堆，其树的根结点含有树中最小的关键字。

​		这个推论我们可以轻松的使用性质2的递归就能证明。以大根堆为例，根结点中的关键字大于等于其左右子结点的关键字，而左右子结点的关键字又同时大于等于其左右子结点的关键字，依此类推就能得出结论。下图是一个典型的大根堆。

==示例:==

​                                                             	![binary_heap1](https://tva1.sinaimg.cn/large/e6c9d24egy1gzx0ubwb21j206u055a9z.jpg)

### 2 二叉堆的表示

​		我们是否需要向二叉树一样用指针连接各个结点呢？其实，事实上是没这个必要的，因为在完全二叉树中，我们按照根据**层序遍历**的顺序将结点中的关键字插入数组(注意，从数组索引为1的位置开始插入，索引为0的的位置空着)。如下图所示。

==示例:==

![binary_heap2](https://tva1.sinaimg.cn/large/e6c9d24egy1gzx18vbuqlj208y071mx8.jpg)

​		我们可以看到存储到数组的主要问题是如何根据当前结点访问到其子结点，在链式结构中，我们有额外的指针表示这个信息。数组中可能稍显困难，但是对于完全二叉树，在上述的排列之后，每个结点就和其子结点建立了关系，假设一个结点的索引为$i$，其**子结点的索引分别为$2i$和$2i+1$** ，就拿上图举例，结点50索引为1，其子结点20和23的索引为$2*1=2$ 和$2*1 +1 =3$ 。下面我们给予简单的证明。

==证明:==

​		假设在堆这棵满二叉树中的第$i$ 层存在一个结点$x$，它是从这一层从左往右数第$k$ 个结点 ，并且其有一个左子结点$x.left$ ，和一个右子结点$x.right$， 我们定义一个运算$index(x)$ 为求该结点的索引值。我们知道对于一棵完全二叉树来说，每一层的第一个结点(假设为$y$) ，其$index(y)=2^{i-1}$ (这是因为前面$i-1$层(把$i$层及以后的层截断)必然是==一棵满二叉树==，这棵满二叉树含有$2^{i-1} + 1$个结点)。所以$index(x)=2^{i-1}+k-1$ 。由于其两个子结点在$i+1$层，所以$index(x.left)$ 必然是$2^{i}+n$ ，其中$n$ 为$x.left$ 前面含有的结点数，我们只要将其求出即可，根据完全二叉树的性质，结点$x$ 前面必然有$k-1$ 个结点，并且每个结点都有两个孩子结点在$i+1$层，总共有$2*(k-1)=2k-2$ 个子结点在$x.left$前面，所以$index(x.left)=2^{i}+2k-2=2(index(x))=2(2^{i-1}+k-1)$ ，于是我们也就推出了$index(x.right)=2(index(x))+1$ 。 得证。

​	  所以根据上面的性质，我们可以从一结点通过访问$array[2*index(x)]$ 和$array[2*index(x)+1]$ 访问其子结点。

## 三、二叉堆的操作	

​		我们这里二叉堆的操作主要是基于大根堆的，小根堆的算法和大根堆是一样的，只不过我们保证的是父结点中存储的关键字大小小于等于$c$ 中关键字大小。

### 1 寻找二叉堆中最大的关键字

​		这个非常简单，就是根结点，同时也是数组存储的索引为1的关键字。

```c++
int maxHeap::findMax()
{
    return _array[1];//返回索引为1的元素即可
}
```

### 2 二叉堆的插入

​		二叉堆的插入需要一些额外的操作。首先我们尽量应该避免过多的开销，由于我们的二叉堆是存储在数组中，因此，我们希望新的关键字插入到数组的最后，而不是数组的第一个位置。其次，我们需要保证其堆的性质，我们把保证其堆性质操作称为==堆化== ，而在插入中，我们将会介绍==向上堆化==($sfit-up$)，

#### 2.1 $sift-up$操作

​		$sift-up$ 操作时非常容易理解的，我们在数组的最后插入新关键字后，我们根据二叉堆的性质，就应该去检查它的父结点是否比它小(大根堆的性质)。如果父结点中的关键字比新的关键字小，那我们就交换两结点的关键字，然后继续向上重复这个步骤，检查交换后新结点所在位置的父结点，直到或者到达根结点或者满足父结点比当前结点大这个条件。

​		这个算法是正确的，假设当前所在结点为$x$ ，父结点为$y$ ，父结点的另一个子结点为$z$，如果$x.key > y.key$ ，那么$x.key>z.key$ 。因为，在插入之前满足堆的性质($y.key>z.key$) 。所以这个交换保证了堆的性质。如果$x.key > y.key$ ，那我们不需要交换就已经满足了堆的性质。

==实现代码:==

```c++
void maxHeap::siftUp(int index)
{
    int parentIndex = index / 2;//获取父结点的索引
    while(parentIndex >= 1)
    {
        //如果父结点关键字比子结点关键字小，则其破话了大根堆的性质，需要将父子结点交换
        if (_array[parentIndex] < _array[index])
        {
            std::swap(_array[parentIndex], _array[index]);
            //之后向上继续调整
            index = parentIndex;
            parentIndex = index / 2;
        }
        else//如果满足了，就无须再向上
        {
            break;
        }
    }
}
```

​		我们通过$index/2$访问其父结点。

==时间复杂度:== 最坏情况下，我们需要遍历到根结点，即位完全二叉树的高度$O(\lceil\log_2{n}\rceil)=O(\lg{n})$。

#### 2.2 借助$sift-up$ 操作实现插入

​		我们先给出一个示例。

==示例:==

![binary_heap3](https://tva1.sinaimg.cn/large/e6c9d24egy1gzy4ld8nysj20ay0x6my9.jpg)

==实现代码:==

```c++
void maxHeap::insert(const int & key)
{
    //如果空间满了，我们需要分配空间，需要注意的是
    //由于我们索引0的空间是空着的，所以当_heapSize == _capacity - 1
    //就应该分配空间
    if (_heapSize + 1 == _capacity)
    {
        allocate(2 * _capacity);
    }
    _array[++_heapSize] = key;
    siftUp(_heapSize);//向上调整堆
}
```

​			$allocate()$为分配内存空间的函数，之前在栈和队列已经介绍过了，这里不再介绍。

==时间复杂度:== $O(\lg{n})$。

### 3 删除最大关键字

​		删除最大关键字，也就是根结点删除，但在数组中这将会造成索引为1的位置为空，由于我们总是以索引为1的位置为根所以需要找一个关键字替代这个。因此，为了减少开销，我们取数组中最后一个关键字放入索引为1的位置。然后这个操作也许会破坏堆的性质，与之前不同的是，这次我们需要做==向下堆化==($sift-down$)。

#### 3.1 $sift-down$操作

​		$sift-down$ 操作也是较好理解的，我们从索引$index$的结点开始，检查其两个孩子结点，我们要找到两个孩子结点中关键字较大的孩子结点，如果这个孩子结点的关键字比当前结点的关键字要大交换两者(所以前面找到两个孩子结点中关键字较大的结点是为了保证交换后满足堆的性质，如果将其中较小关键字的孩子结点交换上去，将会破坏堆的性质，因为另外一个孩子结点关键字比它大)。持续这个操作，直到叶结点或者中途满足了当前结点的关键字比其两个孩子结点都大。

​		我们每一步都保证了堆的性质，因此算法是正确的。

==实现代码:==

```c++
void maxHeap::siftDown(int index)
{
    int childIndex = index * 2;
    while(childIndex <= _heapSize)
    {
        //我们需要将左右孩子结点中较大的结点提升到父结点
        if(childIndex + 1 <= _heapSize && _array[childIndex + 1] > _array[childIndex])
        {
            childIndex += 1;
        }
        //如果父结点的关键字的大小比子结点小，交换两者的值
        if(_array[index] < _array[childIndex])
        {
            std::swap(_array[index], _array[childIndex]);
        }
        else//否则已经满足条件了，无需下降
        {
            break;
        }
        index = childIndex;
        childIndex = index * 2;
    }
}
```

​		我们通过$index*2$和$index*2+1$ 访问其孩子结点

==时间复杂度:== 和$sift-down$ 一样，$O(\lg{n})$。

#### 3.2 借助$sift-down$ 操作实现删除最大关键字

​		首先我们给出一个示例。

==示例:==

![binary_heap4](https://tva1.sinaimg.cn/large/e6c9d24egy1gzy5o6gcl6j20ac0owwf4.jpg)

==实现代码:==

```c++
void maxHeap::deleteMax()
{
    if(empty())
    {
        throw std::runtime_error("you can't use the deleteMax() in empty binary heap!");
    }
    //我们将数组最后一个元素覆盖第一个元素
    _array[1] = _array[_heapSize--];
    siftDown(1);//下降调整
    //如果数组中元素很少，但数组空间又非常大时，需要释放部分空间
    if (_heapSize * 4 <  _capacity)
    {
        allocate(_capacity / 2);
    }
}
```

==时间复杂度:==$O(\lg{n})$

#### 3.3 提取最大关键字并删除

​		在上面的基础上这个操作很简单，只是在删除前我们需要用临时变量保存最大关键字，最后返回临时变量即可。

```c++
int maxHeap::extractMax()
{
    if(empty())
    {
        throw std::runtime_error("you can't use the extractMax() in the empty binary heap!");
    }
    int result = _array[1];//提取首元素
    //我们将数组最后一个元素覆盖第一个元素
    _array[1] = _array[_heapSize--];
    siftDown(1);//下降调整
    //如果数组中元素很少，但数组空间又非常大时，需要释放部分空间
    if (_heapSize * 4 <  _capacity)
    {
        allocate(_capacity / 2);
    }
    return result;
}
```

==时间复杂度:==$O(\lg{n})$

#### 3.4 删除关键字并插入新关键字替代

​		这是我们不使用数组中最后一个关键字替代索引为1的关键字，而是使用新插入的关键字直接替代。这样相比于先$deleteMax$再使用$insert$ 少一次堆化操作。

==实现代码:==

```c++
void maxHeap::replace(const int & key)
{
    if(empty())
    {
        throw std::runtime_error("you can't use the replace() in empty binary heap!");
    }
    _array[1] = key;//直接将首元素替换
    siftDown(1);
}
```

### 4 给定数组建堆(Floyd's algorithm)

​		如果给定一些初始数据，比如一个无序的数组，里面有$n$ 个元素，要在其上建立堆我们最先能想到的是连续使用$insert$ 插入，这种称为自顶向下的建堆方式。我们先来详细探究下这个算法的时间复杂度。

#### 1 自顶向下建堆的时间复杂度

​		假设我们的堆是满二叉树，总共将会插入$n$ 个关键字，那么最终堆的高度为$h=\lfloor\log_2({n+1})\rfloor$ ，以比较次数计量时间复杂度。当插入第一层一个关键字时，需要比较$0$次。当插入第二层$2$个关键字时，每个关键字需要比较$1$次。当插入第三层$4$个关键字时，每个关键需要比较$2$次。当插入第$h$层$2^{h-1}$个关键字时，每个关键字需要比较$h-1$次具体如下所示:

==示例:==

![binary_heap5](https://tva1.sinaimg.cn/large/e6c9d24egy1gzzwtdbm7cj20em08kt8s.jpg)

​		

​		所以我们总共需要的比较次数:
$$
S_h=1*0+2*1+4*2\dots+2^{h-1}*(h-1)=\sum_{i=1}^{i=h}{(i-1)*2^{i-1}}\qquad(1)
$$
​		这是一个典型的差比数列求和，可以用错位相减法求得，这是高中数学的内容，其中等差数列为:$a_{h1}=-1+h$，等比数列为:$a_{h2}=1*2^{h-1}$。
$$
2*S_{h}=2*0+4*1+8*2+\dots+2^{h}*(h-1)\qquad\qquad\qquad\qquad\space\space(2)
$$
​		用$(1)$减去$(2)$ ,错位相减得:
$$
S_{h}=2+4+8\dots+2^{h-1}-2^{h}*(h-1)=-2*(2^{h}-1)+2^{h}*(h-1)\space\space
$$
​		最后代入$h=\lfloor\log_2({n+1})\rfloor$ ，可以得到其时间复杂度为$O(n\lg{n})$。

​		这个复杂度是不理想的，显然我们可以有一个更好的建堆方法，自顶向下建堆算法的问题在于，当我们在后面的每一层的结点越多，所需要做的比较次数就越多。而刚开始每一层的结点较少时，所需要的比较次数就少。我们希望的是在后面的每一层结点较多时后，需要更少的比较次数，而刚开始的每一层结点数较少时，比较次数可以多一点，这样可以保证整体的比较次树会少一些(其中主要是利用了$\log_2{n}$增长较慢的特点)。而每一层结点的比较次数和其高度有关。所以一个奇妙的点子就应运而生了，我们可以==自底向上==构建二叉堆，这样结点最多的最后一层，只需要0次比较。倒数第二层的每个结点只需要1次比较，依次类推。

#### 2 自底向上建堆的$Floyd's Algorithm$

​		我们把自底向上建堆称为$Floyd's Algorithm$，对于满二叉树来说最后一层是不用比较的(即堆化操作)，我们只需要从倒数第二层开始，对每个结点使用$sift\_down()$操作即可(这里你需要注意的是自底向上建堆的$up$ 和操作$sift\_up()$中的$up$ 两者并没有直接联系，用$sift\_down$是因为这样可以保证以每个结点的子树堆化变为子堆，从而递归地保证整棵树保持堆的性质)，除了最后一层外的剩余结点数为$n/2$。所以我们只需要依次逆序从索引为$n/2$ 到索引为$0$的结点做$sift\_down()$ 操作即可。对于非满二叉树(但其是完全二叉树)，也是同样从索引为$n/2$ 到索引为$0$的结点做$sift\_down()$ 操作即可。原因先看下图:

==示例:==

​                                                      		![binary_heap6](https://tva1.sinaimg.cn/large/e6c9d24egy1h0037q592ij20a80773ym.jpg)

​		对于橙色方框内的结点(也就是所有叶结点)我们无需对其做$sift\_down()$ ，而在完全二叉树中，非叶结点的数量为总的结点数量的$1/2$(向下取整) ，因此我们同样是从也是同样从索引为$n/2$ 到索引为$0$的结点做$sift\_down()$ 操作即可。



==实现代码:==

```c++
void maxHeap::createHeap(int* array, int size)
{
    if(_array != nullptr)
    {
        delete [] _array;
    }
    _heapSize = size;
    _capacity = size << 1;//左移1位相当于乘2
    _array = new int[2 * size];
    for(int i = 0; i < size; i++)
    {
        _array[i + 1] = array[i];
    }//拷贝；
    for (size_t i = _heapSize / 2; i >= 1; i--)
    {
        siftDown(i);
    }
}
```

​		上述代码可以不进行拷贝，直接原地堆化。

==时间复杂度:==下面我们来证明$Floyd's Algorithm$算法的时间复杂度为$O(n)$。

​		我们还是根据比较次数来判定，假设该堆是一个满二叉树。

​		对于最底层，每个结点只需要0次比较，倒数第二层每个结点需要$1$次比较(堆化)，倒数第三层每个结点需要$2$次比较，...依次类推，最顶层根结点需要$h-1$ 次比较。总共的比较次数为:
$$
S_{h}=1*(h-1)+2*(h-2)+\dots+2^{h-2}*1+2^{h-1}*0=\sum_{i=0}^{h-1}{2^{i}*(h-i-1)}\qquad(1)
$$
​		这依然是一个差比数列，我们仍然可以用错位相减法去求解。
$$
2*S_{h}=2*(h-1)+4*(h-2)+\dots+2^{h-1}*1+2^{h}*0\qquad\qquad\qquad\qquad\qquad\space\space(2)
$$
​		$(1)-(2)$，推出:
$$
S_{h}=-(h-1)+2^{1}+2^{2}\dots+2^{h-1}=-h+2^{h}-1\qquad\qquad\qquad\qquad\qquad\qquad\qquad\space\space
$$
​		最后代入$h=\lfloor\log_2({n+1})\rfloor$，原式子约等于$-\lfloor\log_2({n+1})\rfloor+n-1$

​		因此时间复杂度为$O(n)$.

## 四、应用场景

### 1 堆排序

​		堆排序顾名思义就是利用堆来进行排序我们可以将一个无序的序列进行建堆，然后如果是==大根堆==，我们利用其根结点总是为最大关键字的性质，每次调用$extractMax()$ 提取最大关键字并且从后往前排列。当堆被提取空时，生成的就是原来无序序列的顺序序列了。

==实现代码:==

```c++
void heapSort(int* array, int size)
{
    maxHeap heap(array, size);//建堆
    for (int i = size - 1; i >= 0; i--)
    {
        array[i] = heap.extractMax();
    }
}
```

​		实现非常简单，不在赘述。

==时间复杂度:==建堆的时间$\theta(n)$ 加上，$n$次$extractMax()$的时间$O(n\lg{n})$ ，合起来为$O(n+n\lg{n})=O(\lg{n})$。

​		当然上述算法最好的方式在数组上==原地==使用$Floyd's  algorithm$ 建堆，而不是先拷贝再建堆，然后在堆上使用==原地== 堆排序，每次提取的关键字，插在堆的$\_heapSize+1$的位置 ，这里不再演示。

## 五、如有错误或描述不当，请多多指教！不胜感激！

![58b3b71e5cdfd4bc8459ff135882af0d](https://tva1.sinaimg.cn/large/e6c9d24egy1h0051ijje1j20p70p7mzl.jpg)																																																		2022年 3月6日

​                                                                                                   	                                                                     weekie_OUO
