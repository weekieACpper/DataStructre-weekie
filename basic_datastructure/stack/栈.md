# 栈

## 一、一些在学习此内容所需要的准备

### 1 需要提前了解的知识

​	1、时间复杂度的计算，以及记号。

​	2、熟悉c或c++的基本语法。

## 二、栈的定义

​		栈是一种非常好理解的数据结构，我们只需要将如下数组逆时针旋转90度，然后就像盖房子一样，我们只在顶端实现插入元素操作和删除元素操作。

==示例:==

![stack1](https://tva1.sinaimg.cn/large/e6c9d24egy1gzoc6uyfguj20de05xmx4.jpg)

​		如上图所示，我们将最顶端的元素称为==栈顶元素== ，在上图中是6，而该元素所处的位置称为==栈顶==。

### 2.1 栈的性质

​		(1) 栈插入元素时，只能在栈顶之后的那个位置插入，插入完后将成为新栈顶，我们把这个操作叫==压栈==。

​		(2) 栈删除元素时，只能将栈顶元素删除，并更新栈顶，我们把这个操作叫==弹栈==。

​		(3) 栈是一种后进先出(last-in,first-out,LIFO)的数据结构，被删除的是最近插入的元素。

​		性质3还是很好理解的，拿上面那张图举例，上面那个栈是有连续6个压栈形成，在后续弹栈的过程中，最早入栈的1最晚被弹出，最晚入栈的6最先被弹出。

## 三、栈的操作

​		我们可以用数组来模拟栈，其中我们只要将数组的尾端当场栈顶即可。我们用$top$记录栈顶在数组中的下标。

### 3.1 返回栈顶元素

==实现代码:==

```c++
int stack::top()
{
    if (stack::empty())
    {
        throw std::runtime_error("you can't use top() in a empty stack");
    }
    return _array[_top];
}
```

​		这里只需要注意我们不能访问一个空栈的栈顶。

==时间复杂度:==$O(1)$。

### 3.2 检查栈是否为空

==实现代码:==

```c++
bool stack::empty()
{
    return _top == -1;
}
```

​		一个空栈栈顶的位置都是-1，这是在构造函数初始化时确定的，详情见完整代码。

==时间复杂度:==$O(1)$.

### 3.3 压栈

​		由于使用的是数组，我们需要考虑是否会出溢出的现象，也就是说当数组满时，我们需要额外的空间去存放新的元素，硬刺我们使用的动态数组。在需要时我们使用额外的allocate函数分配空间，allocate函数如下。

==实现代码:==

```c++
void stack::allocate(const int & capacity)
{
    _capacity = capacity;
    int* temp = new int[_capacity];//先分配信的一段内存
    for (size_t i = 0; i <= _top; i++)
    {
        temp[i] = _array[i];//复制
    }
    delete [] _array;//释放原来的内存
    _array = temp;//指向性新的内存
}
```

​		我们首先分配一段新的空间，然后将原来的数组空间中的元素分配到新的空间中去，然后释放释放原来的空间，最后，使_array指向新的内存空间。其中_capacity记录了_array所拥有的内存空间的大小是stack类的成员，具体见完整代码。

==时间复杂度:== $O(n)$ ,其中$n$为栈中元素的个数。

​		下面实现压栈操作。

==实现代码:==

```c++
void stack::push(const int & value)
{
    if(_top + 1 == _capacity)//当当前空间已经用完时，需要分配新空间
    {
        allocate(2 * _capacity);
    }
    _array[++_top] = value;
}
```

​		我们在数组空间用完时，重新分配2倍原来的空间去存储。

==时间复杂度:==$O(1)$ ,由于发生上溢的情况很罕见，所以总体上可以忽略分配空间的开销。

### 3.4 弹栈

​		弹栈我们只需要考虑当前栈是否空栈，因为对空栈弹栈是不合理的。其次就是为了避免浪费太多空间，当栈中元素个数特别，而已分配的空间又过大时，我们需要释放部分空间，同样可以利用allocate函数去完成。

==实现代码:==

```c++
void stack::pop()
{
    if (_top == -1)
    {
        throw std::runtime_error("you can't use pop() in a empty stack");
    }
    _top--;//只需将栈顶位置在数组中的下标-1即可
    if ((_top + 1) * 4 <= _capacity)//如果数组中实际使用的空间不到分配空间的4分之1时，我们需要释放capacity/2的空间
    {
        allocate(capacity / 2);
    }
}
```

==时间复杂度:==$O(1)$ 。

## 四、应用场景

​		这是一个简单但非常重要的数据结构，基本上所有的递归算法都可以用栈来模拟，因为递归和栈同样具有LIFO的性质。栈在计算机领域无处不在。

## 五、如有错误或描述不当，请多多指教！不胜感激！

![07f65a8c7474a077183b9a2022608a2f](https://tva1.sinaimg.cn/large/e6c9d24egy1gzoem1k5sgj20u00u0go2.jpg)

​																																																	 2022年2月24日

​                                                                                                   	                                                                     weekie_OUO